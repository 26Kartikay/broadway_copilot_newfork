import type { FunctionTool as OpenAIFunctionTool } from 'openai/resources/responses/responses';
import { z, ZodObject, ZodType } from 'zod';

type ToolSchema = ZodObject<Record<string, ZodType>>;

/**
 * Defines the structure for a tool that the model can call. Each tool has a
 * name, description, a Zod schema for its arguments, and a function to execute.
 *
 * @template T The shape of the Zod schema for the tool's arguments.
 *
 * @example
 * ```typescript
 * const weatherTool: Tool<{ location: string }> = {
 *   name: 'get_weather',
 *   description: 'Get the current weather for a given location.',
 *   schema: z.object({
 *     location: z.string().describe('The city to get the weather for.'),
 *   }),
 *   func: async ({ location }) => {
 *     // In a real application, this would call a weather API.
 *     return { temperature: 22, condition: 'sunny' };
 *   },
 * };
 * ```
 */
export class Tool<TSchema extends ToolSchema = ToolSchema, TResult = unknown> {
  /** The name of the tool. Must be unique among all tools provided to the model. */
  name: string;
  /** A detailed description of what the tool does, used by the model to decide when to use it. */
  description: string;
  /** The Zod schema that defines the arguments the tool accepts. */
  schema: TSchema;
  /** The function to execute when the tool is called. It receives the parsed arguments. */
  func: (args: z.infer<TSchema>) => TResult | Promise<TResult>;

  constructor(config: {
    name: string;
    description: string;
    schema: TSchema;
    func: (args: z.infer<TSchema>) => TResult | Promise<TResult>;
  }) {
    this.name = config.name;
    this.description = config.description;
    this.schema = config.schema;
    this.func = config.func;
  }
}

/**
 * Represents a tool call request generated by the model.
 *
 * @example
 * ```typescript
 * const toolCall: ToolCall = {
 *   id: 'call_abc123',
 *   name: 'get_weather',
 *   arguments: { location: 'New York' },
 * };
 * ```
 */
export interface ToolCall {
  /** A unique identifier for this specific tool call. */
  id: string;
  /** The name of the tool the model wants to call. */
  name: string;
  /** The arguments for the tool, parsed as a JSON object. */
  arguments: unknown;
}

/**
 * Represents the result of a single tool execution. This is typically created
 * by the agent executor after running a tool.
 *
 * @example
 * ```typescript
 * const toolResult: ToolResult = {
 *   id: 'call_abc123',
 *   name: 'get_weather',
 *   result: { temperature: 22, condition: 'sunny' },
 * };
 * ```
 */
export interface ToolResult {
  /** The unique ID of the tool call this result corresponds to. */
  id: string;
  /** The name of the tool that was executed. */
  name: string;
  /** The output of the tool execution. */
  result: unknown;
}

/**
 * A utility function that converts a `Tool` into a specification that is
 * compatible with the OpenAI/Groq API's `tools` parameter.
 *
 * @param tool The tool to convert.
 * @returns An OpenAI-compatible function tool specification.
 *
 * @example
 * ```typescript
 * const openAISpec = toOpenAIToolSpec(weatherTool);
 * console.log(openAISpec);
 * // {
 * //   type: 'function',
 * //   name: 'get_weather',
 * //   description: 'Get the current weather for a given location.',
 * //   parameters: { ...Zod schema as JSON schema... },
 * //   strict: true
 * // }
 * ```
 */
/**
 * Recursively ensures all nested objects in JSON schema have a 'required' array.
 * OpenAI requires this for function calling schemas.
 * Exported so it can be used for structured output schemas as well.
 */
export function ensureRequiredArrays(schema: any): any {
  if (typeof schema !== 'object' || schema === null) {
    return schema;
  }

  // Handle schemas with additionalProperties but no type FIRST (before other processing)
  // OpenAI requires type when additionalProperties is present
  if ('additionalProperties' in schema && !schema.type) {
    const processed = {
      ...schema,
      type: 'object',
      properties: schema.properties || {},
    };
    // Continue processing the fixed schema recursively
    return ensureRequiredArrays(processed);
  }

  // Handle object types
  if (schema.type === 'object') {
    const processed: any = { ...schema };

    // Ensure 'type' is always present (OpenAI requirement)
    if (!processed.type) {
      processed.type = 'object';
    }

    // If it has properties, process them
    if (processed.properties && Object.keys(processed.properties).length > 0) {
      // Recursively process nested properties first
      const processedProperties: Record<string, any> = {};
      for (const [key, value] of Object.entries(processed.properties)) {
        processedProperties[key] = ensureRequiredArrays(value);
      }
      processed.properties = processedProperties;

      // OpenAI strict mode requires: if you have properties, you MUST have a 'required' array
      // And if you have a 'required' array, it must include ALL property keys
      // This is unusual but appears to be OpenAI's requirement
      const allPropertyKeys = Object.keys(processedProperties);
      if (allPropertyKeys.length > 0) {
        // Always include all properties in required array for OpenAI compatibility
        processed.required = allPropertyKeys;
      }
    } else {
      // If it's an object type but has no properties, remove 'required' if present
      // (OpenAI doesn't allow 'required' without 'properties')
      if ('required' in processed) {
        delete processed.required;
      }
      // Ensure it has an empty properties object for OpenAI compatibility
      if (!processed.properties) {
        processed.properties = {};
      }
    }

    // If additionalProperties is present, ensure type is also present (OpenAI requirement)
    if ('additionalProperties' in processed && !processed.type) {
      processed.type = 'object';
    }

    return processed;
  }

  // Recursively process arrays
  if (schema.type === 'array' && schema.items) {
    return {
      ...schema,
      items: ensureRequiredArrays(schema.items),
    };
  }

  // Handle anyOf - often used for optional fields (e.g., z.object({}).optional())
  if (schema.anyOf) {
    const processedAnyOf = schema.anyOf.map((item: any) => ensureRequiredArrays(item));

    // If anyOf contains an object type, ensure it's properly processed
    const objectItem = processedAnyOf.find(
      (item: any) => item.type === 'object' && item.properties,
    );
    if (objectItem && objectItem.properties && Object.keys(objectItem.properties).length > 0) {
      if (!('required' in objectItem)) {
        objectItem.required = [];
      }
    }

    return {
      ...schema,
      anyOf: processedAnyOf,
    };
  }

  // Recursively process oneOf, allOf
  if (schema.oneOf) {
    return {
      ...schema,
      oneOf: schema.oneOf.map((item: any) => ensureRequiredArrays(item)),
    };
  }
  if (schema.allOf) {
    return {
      ...schema,
      allOf: schema.allOf.map((item: any) => ensureRequiredArrays(item)),
    };
  }

  return schema;
}

export function toOpenAIToolSpec(tool: Tool): OpenAIFunctionTool {
  const rawSchema = z.toJSONSchema(tool.schema) as Record<string, unknown>;

  // Post-process to ensure OpenAI compatibility (required arrays for nested objects)
  let processedSchema = ensureRequiredArrays(rawSchema);

  // Final safety check: if additionalProperties exists without type, fix it
  if (typeof processedSchema === 'object' && processedSchema !== null) {
    if ('additionalProperties' in processedSchema && !processedSchema.type) {
      processedSchema = {
        ...processedSchema,
        type: 'object',
        properties: processedSchema.properties || {},
      };
    }
  }

  return {
    type: 'function',
    name: tool.name,
    description: tool.description,
    parameters: processedSchema,
    // Allow non-strict to reduce Groq tool validation failures on minor argument shape deviations.
    strict: true,
  };
}
