"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StructuredOutputRunnable = void 0;
class StructuredOutputRunnable {
    runner;
    schema;
    constructor(runner, schema) {
        this.runner = runner;
        this.schema = schema;
    }
    _extractJson(text) {
        const match = text.match(/```(?:json)?\s*([\s\S]*?)\s*```/);
        return match?.[1] ?? text;
    }
    _coerceSchema(schema) {
        return schema;
    }
    async run(systemPrompt, messages, traceBuffer, nodeName) {
        const response = await this.runner.run(systemPrompt, messages, traceBuffer, nodeName);
        const { toolCalls } = response;
        let data;
        if (toolCalls.length > 0) {
            const structuredToolCall = toolCalls.find((tc) => tc.name === this.runner.structuredOutputToolName);
            if (structuredToolCall) {
                data = structuredToolCall.arguments;
            }
        }
        if (data === undefined) {
            const textContent = response.assistant.content
                .filter((p) => p.type === 'text')
                .map((p) => p.text)
                .join('');
            const jsonString = this._extractJson(textContent);
            if (jsonString === '') {
                throw new Error(`Failed to extract JSON from model output. Content: ${textContent}`);
            }
            try {
                data = JSON.parse(jsonString);
            }
            catch (error) {
                throw new Error(`Failed to parse structured output as JSON: ${error}\nContent: ${jsonString}`);
            }
        }
        try {
            const coercedSchema = this._coerceSchema(this.schema);
            return coercedSchema.parse(data);
        }
        catch (error) {
            throw new Error(`Failed to validate structured output: ${error}\nData: ${JSON.stringify(data, null, 2)}`);
        }
    }
}
exports.StructuredOutputRunnable = StructuredOutputRunnable;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL3Vzci9zcmMvYXBwL3NyYy9saWIvYWkvY29yZS9zdHJ1Y3R1cmVkX291dHB1dF9ydW5uYWJsZS50cyIsInNvdXJjZXMiOlsiL3Vzci9zcmMvYXBwL3NyYy9saWIvYWkvY29yZS9zdHJ1Y3R1cmVkX291dHB1dF9ydW5uYWJsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUEwQkEsTUFBYSx3QkFBd0I7SUFNekI7SUFDQTtJQUZWLFlBQ1UsTUFBcUIsRUFDckIsTUFBUztRQURULFdBQU0sR0FBTixNQUFNLENBQWU7UUFDckIsV0FBTSxHQUFOLE1BQU0sQ0FBRztJQUNoQixDQUFDO0lBRUksWUFBWSxDQUFDLElBQVk7UUFDL0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO1FBQzVELE9BQU8sS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDO0lBQzVCLENBQUM7SUFFTyxhQUFhLENBQUMsTUFBZTtRQUNuQyxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBa0JELEtBQUssQ0FBQyxHQUFHLENBQ1AsWUFBMkIsRUFDM0IsUUFBdUIsRUFDdkIsV0FBd0IsRUFDeEIsUUFBZ0I7UUFFaEIsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsUUFBUSxFQUFFLFdBQVcsRUFBRSxRQUFRLENBQUMsQ0FBQztRQUN0RixNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsUUFBUSxDQUFDO1FBRS9CLElBQUksSUFBYSxDQUFDO1FBRWxCLElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQztZQUN6QixNQUFNLGtCQUFrQixHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQ3ZDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsd0JBQXdCLENBQ3pELENBQUM7WUFDRixJQUFJLGtCQUFrQixFQUFFLENBQUM7Z0JBQ3ZCLElBQUksR0FBRyxrQkFBa0IsQ0FBQyxTQUFTLENBQUM7WUFDdEMsQ0FBQztRQUNILENBQUM7UUFFRCxJQUFJLElBQUksS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUN2QixNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDLE9BQU87aUJBQzNDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBaUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssTUFBTSxDQUFDO2lCQUMvQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7aUJBQ2xCLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUVaLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLENBQUM7WUFFbEQsSUFBSSxVQUFVLEtBQUssRUFBRSxFQUFFLENBQUM7Z0JBQ3RCLE1BQU0sSUFBSSxLQUFLLENBQUMsc0RBQXNELFdBQVcsRUFBRSxDQUFDLENBQUM7WUFDdkYsQ0FBQztZQUVELElBQUksQ0FBQztnQkFDSCxJQUFJLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQVksQ0FBQztZQUMzQyxDQUFDO1lBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztnQkFDZixNQUFNLElBQUksS0FBSyxDQUNiLDhDQUE4QyxLQUFLLGNBQWMsVUFBVSxFQUFFLENBQzlFLENBQUM7WUFDSixDQUFDO1FBQ0gsQ0FBQztRQUVELElBQUksQ0FBQztZQUNILE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3RELE9BQU8sYUFBYSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztZQUNmLE1BQU0sSUFBSSxLQUFLLENBQ2IseUNBQXlDLEtBQUssV0FBVyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FDekYsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUFyRkQsNERBcUZDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWm9kVHlwZSB9IGZyb20gJ3pvZCc7XG5pbXBvcnQgeyBUcmFjZUJ1ZmZlciB9IGZyb20gJy4uLy4uLy4uL2FnZW50L3RyYWNpbmcnO1xuaW1wb3J0IHsgQmFzZUNoYXRNb2RlbCB9IGZyb20gJy4vYmFzZV9jaGF0X21vZGVsJztcbmltcG9ydCB7IEJhc2VNZXNzYWdlLCBTeXN0ZW1NZXNzYWdlLCBUZXh0UGFydCB9IGZyb20gJy4vbWVzc2FnZXMnO1xuXG4vKipcbiAqIEEgcnVubmFibGUgdGhhdCB3cmFwcyBhIGNoYXQgbW9kZWwgYW5kIGZvcmNlcyBpdCB0byBwcm9kdWNlIGEgSlNPTiBvYmplY3RcbiAqIHRoYXQgY29uZm9ybXMgdG8gYSBwcm92aWRlZCBab2Qgc2NoZW1hLiBJdCBoYW5kbGVzIEpTT04gZXh0cmFjdGlvbiwgcGFyc2luZyxcbiAqIGFuZCB2YWxpZGF0aW9uLCByZXR1cm5pbmcgYSB0eXBlZCBvYmplY3Qgb24gc3VjY2Vzcy5cbiAqXG4gKiBAdGVtcGxhdGUgVCBUaGUgWm9kIHR5cGUgb2YgdGhlIHNjaGVtYS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3Qgc2NoZW1hID0gei5vYmplY3Qoe1xuICogICBuYW1lOiB6LnN0cmluZygpLmRlc2NyaWJlKCdUaGUgbmFtZSBvZiB0aGUgdXNlcicpLFxuICogICBhZ2U6IHoubnVtYmVyKCkuZGVzY3JpYmUoJ1RoZSBhZ2Ugb2YgdGhlIHVzZXInKSxcbiAqIH0pO1xuICpcbiAqIGNvbnN0IHN0cnVjdHVyZWRNb2RlbCA9IG1vZGVsLndpdGhTdHJ1Y3R1cmVkT3V0cHV0KHNjaGVtYSk7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJ1Y3R1cmVkTW9kZWwucnVuKFxuICogICBbbmV3IFVzZXJNZXNzYWdlKCdFeHRyYWN0IGluZm8gZnJvbTogSm9obiBEb2UgaXMgMzAgeWVhcnMgb2xkLicpXVxuICogKTtcbiAqIC8vIHJlc3VsdCBpcyB7IG5hbWU6ICdKb2huIERvZScsIGFnZTogMzAgfVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHJ1Y3R1cmVkT3V0cHV0UnVubmFibGU8VCBleHRlbmRzIFpvZFR5cGU+IHtcbiAgLyoqXG4gICAqIEBwYXJhbSBydW5uZXIgVGhlIG1vZGVsIHJ1bm5lciB0byB3cmFwLlxuICAgKiBAcGFyYW0gc2NoZW1hIFRoZSBab2Qgc2NoZW1hIHRvIHZhbGlkYXRlIHRoZSBvdXRwdXQgYWdhaW5zdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcnVubmVyOiBCYXNlQ2hhdE1vZGVsLFxuICAgIHByaXZhdGUgc2NoZW1hOiBULFxuICApIHt9XG5cbiAgcHJpdmF0ZSBfZXh0cmFjdEpzb24odGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2goL2BgYCg/Ompzb24pP1xccyooW1xcc1xcU10qPylcXHMqYGBgLyk7XG4gICAgcmV0dXJuIG1hdGNoPy5bMV0gPz8gdGV4dDtcbiAgfVxuXG4gIHByaXZhdGUgX2NvZXJjZVNjaGVtYShzY2hlbWE6IFpvZFR5cGUpOiBab2RUeXBlIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBtb2RlbCBhbmQgcGFyc2VzIHRoZSBvdXRwdXQgYWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEuXG4gICAqXG4gICAqIEBwYXJhbSBtZXNzYWdlcyBUaGUgbWVzc2FnZXMgdG8gc2VuZCB0byB0aGUgbW9kZWwuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBwYXJzZWQgYW5kIHZhbGlkYXRlZCBvdXRwdXQgb2JqZWN0LlxuICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIHRoZSBtb2RlbCBvdXRwdXQgaXMgbm90IHZhbGlkIEpTT04gb3IgZG9lcyBub3RcbiAgICogbWF0Y2ggdGhlIHByb3ZpZGVkIHNjaGVtYS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiBjb25zdCByZXN1bHQgPSBhd2FpdCBzdHJ1Y3R1cmVkTW9kZWwucnVuKFxuICAgKiAgIFtuZXcgVXNlck1lc3NhZ2UoJ015IG5hbWUgaXMgSmFuZSwgSSBhbSAyNS4nKV1cbiAgICogKTtcbiAgICogLy8gcmVzdWx0IGlzIGZ1bGx5IHR5cGVkIGFuZCB2YWxpZGF0ZWQ6IHsgbmFtZTogJ0phbmUnLCBhZ2U6IDI1IH1cbiAgICogYGBgXG4gICAqL1xuICBhc3luYyBydW4oXG4gICAgc3lzdGVtUHJvbXB0OiBTeXN0ZW1NZXNzYWdlLFxuICAgIG1lc3NhZ2VzOiBCYXNlTWVzc2FnZVtdLFxuICAgIHRyYWNlQnVmZmVyOiBUcmFjZUJ1ZmZlcixcbiAgICBub2RlTmFtZTogc3RyaW5nLFxuICApOiBQcm9taXNlPFRbJ19vdXRwdXQnXT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5ydW5uZXIucnVuKHN5c3RlbVByb21wdCwgbWVzc2FnZXMsIHRyYWNlQnVmZmVyLCBub2RlTmFtZSk7XG4gICAgY29uc3QgeyB0b29sQ2FsbHMgfSA9IHJlc3BvbnNlO1xuXG4gICAgbGV0IGRhdGE6IHVua25vd247XG5cbiAgICBpZiAodG9vbENhbGxzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHN0cnVjdHVyZWRUb29sQ2FsbCA9IHRvb2xDYWxscy5maW5kKFxuICAgICAgICAodGMpID0+IHRjLm5hbWUgPT09IHRoaXMucnVubmVyLnN0cnVjdHVyZWRPdXRwdXRUb29sTmFtZSxcbiAgICAgICk7XG4gICAgICBpZiAoc3RydWN0dXJlZFRvb2xDYWxsKSB7XG4gICAgICAgIGRhdGEgPSBzdHJ1Y3R1cmVkVG9vbENhbGwuYXJndW1lbnRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gcmVzcG9uc2UuYXNzaXN0YW50LmNvbnRlbnRcbiAgICAgICAgLmZpbHRlcigocCk6IHAgaXMgVGV4dFBhcnQgPT4gcC50eXBlID09PSAndGV4dCcpXG4gICAgICAgIC5tYXAoKHApID0+IHAudGV4dClcbiAgICAgICAgLmpvaW4oJycpO1xuXG4gICAgICBjb25zdCBqc29uU3RyaW5nID0gdGhpcy5fZXh0cmFjdEpzb24odGV4dENvbnRlbnQpO1xuXG4gICAgICBpZiAoanNvblN0cmluZyA9PT0gJycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZXh0cmFjdCBKU09OIGZyb20gbW9kZWwgb3V0cHV0LiBDb250ZW50OiAke3RleHRDb250ZW50fWApO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShqc29uU3RyaW5nKSBhcyB1bmtub3duO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gcGFyc2Ugc3RydWN0dXJlZCBvdXRwdXQgYXMgSlNPTjogJHtlcnJvcn1cXG5Db250ZW50OiAke2pzb25TdHJpbmd9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY29lcmNlZFNjaGVtYSA9IHRoaXMuX2NvZXJjZVNjaGVtYSh0aGlzLnNjaGVtYSk7XG4gICAgICByZXR1cm4gY29lcmNlZFNjaGVtYS5wYXJzZShkYXRhKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIHZhbGlkYXRlIHN0cnVjdHVyZWQgb3V0cHV0OiAke2Vycm9yfVxcbkRhdGE6ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgMil9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=