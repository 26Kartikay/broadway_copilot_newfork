"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StateGraph = exports.END = exports.START = void 0;
const cuid2_1 = require("@paralleldrive/cuid2");
exports.START = 'START';
exports.END = 'END';
class StateGraph {
    nodes = new Map();
    edges = new Map();
    startNode = '';
    addNode(name, node) {
        if (this.nodes.has(name)) {
            throw new Error(`Node "${name}" is already defined.`);
        }
        this.nodes.set(name, node);
        return this;
    }
    addEdge(source, target) {
        if (source === exports.START) {
            if (this.startNode) {
                throw new Error('Start node is already defined.');
            }
            this.startNode = target;
            return this;
        }
        if (this.edges.has(source)) {
            throw new Error(`An edge from "${source}" is already defined.`);
        }
        this.edges.set(source, { source, target });
        return this;
    }
    addConditionalEdges(source, resolver, targets) {
        if (this.edges.has(source)) {
            throw new Error(`An edge from "${source}" is already defined.`);
        }
        this.edges.set(source, { source, resolver, targets });
        return this;
    }
    compile() {
        if (!this.startNode) {
            throw new Error('Graph must have a starting point defined with `addEdge(START, ...)`.');
        }
        return {
            invoke: async (initialState, config = {}) => {
                let currentNodeName = this.startNode;
                let currentState = { ...initialState };
                const { signal, runId: graphRunId } = config;
                while (currentNodeName !== exports.END) {
                    if (signal?.aborted) {
                        const error = new Error('Graph execution aborted');
                        error.name = 'AbortError';
                        throw error;
                    }
                    const currentNode = this.nodes.get(currentNodeName);
                    if (!currentNode) {
                        throw new Error(`Node "${currentNodeName}" not found.`);
                    }
                    const startTime = new Date();
                    const nodeRunId = (0, cuid2_1.createId)();
                    const traceCandidate = currentState.traceBuffer;
                    const traceBuffer = graphRunId && traceCandidate ? traceCandidate : null;
                    let nodeRunEntry = null;
                    if (traceBuffer) {
                        nodeRunEntry = {
                            id: nodeRunId,
                            nodeName: currentNodeName,
                            startTime,
                            createdAt: startTime,
                            updatedAt: startTime,
                        };
                        traceBuffer.nodeRuns.push(nodeRunEntry);
                    }
                    let stateUpdate;
                    try {
                        stateUpdate = await currentNode(currentState);
                    }
                    catch (e) {
                        throw e;
                    }
                    if (nodeRunEntry) {
                        const endTime = new Date();
                        nodeRunEntry.endTime = endTime;
                        nodeRunEntry.durationMs = endTime.getTime() - startTime.getTime();
                        nodeRunEntry.updatedAt = endTime;
                    }
                    if (stateUpdate !== undefined) {
                        currentState = { ...currentState, ...stateUpdate };
                    }
                    const edge = this.edges.get(currentNodeName);
                    if (!edge) {
                        throw new Error(`No edge found from node "${currentNodeName}". All nodes must have an outgoing edge.`);
                    }
                    if ('target' in edge) {
                        currentNodeName = edge.target;
                    }
                    else {
                        const targetKey = edge.resolver(currentState);
                        const nextNode = edge.targets[targetKey];
                        if (!nextNode) {
                            throw new Error(`Conditional edge from "${currentNodeName}" resolved to "${targetKey}", which is not a valid target.`);
                        }
                        currentNodeName = nextNode;
                    }
                }
                return currentState;
            },
        };
    }
}
exports.StateGraph = StateGraph;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiL3Vzci9zcmMvYXBwL3NyYy9saWIvZ3JhcGgudHMiLCJzb3VyY2VzIjpbIi91c3Ivc3JjL2FwcC9zcmMvbGliL2dyYXBoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGdEQUFnRDtBQVFuQyxRQUFBLEtBQUssR0FBRyxPQUFnQixDQUFDO0FBQ3pCLFFBQUEsR0FBRyxHQUFHLEtBQWMsQ0FBQztBQStCbEMsTUFBYSxVQUFVO0lBQ0osS0FBSyxHQUFHLElBQUksR0FBRyxFQUFnQyxDQUFDO0lBQ2hELEtBQUssR0FBRyxJQUFJLEdBQUcsRUFBZ0QsQ0FBQztJQUN6RSxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBUXZCLE9BQU8sQ0FBQyxJQUFZLEVBQUUsSUFBMEI7UUFDOUMsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQUMsU0FBUyxJQUFJLHVCQUF1QixDQUFDLENBQUM7UUFDeEQsQ0FBQztRQUNELElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUMzQixPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFRRCxPQUFPLENBQUMsTUFBYyxFQUFFLE1BQWM7UUFDcEMsSUFBSSxNQUFNLEtBQUssYUFBSyxFQUFFLENBQUM7WUFDckIsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQ25CLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQztZQUNwRCxDQUFDO1lBQ0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxNQUFNLENBQUM7WUFDeEIsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQUMsaUJBQWlCLE1BQU0sdUJBQXVCLENBQUMsQ0FBQztR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YXJhbGxlbGRyaXZlL2N1aWQyJztcbmltcG9ydCB0eXBlIHsgQnVmZmVyZWROb2RlUnVuLCBUcmFjZUJ1ZmZlciB9IGZyb20gJy4uL2FnZW50L3RyYWNpbmcnO1xuXG4vKipcbiAqIEBmaWxlIEEgY3VzdG9tLCBsaWdodHdlaWdodCBpbXBsZW1lbnRhdGlvbiBvZiBhIHN0YXRlIGdyYXBoIGluc3BpcmVkIGJ5IExhbmdHcmFwaC5cbiAqIEl0IHN1cHBvcnRzIG5vZGVzLCBlZGdlcywgYW5kIGNvbmRpdGlvbmFsIGVkZ2VzIHRvIGJ1aWxkIGFuZCBydW4gc3RhdGVmdWwsIGN5Y2xpY2FsIGdyYXBocy5cbiAqL1xuXG5leHBvcnQgY29uc3QgU1RBUlQgPSAnU1RBUlQnIGFzIGNvbnN0O1xuZXhwb3J0IGNvbnN0IEVORCA9ICdFTkQnIGFzIGNvbnN0O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBleGVjdXRlZCBhcyBhIG5vZGUgaW4gdGhlIGdyYXBoLlxuICogSXQgcmVjZWl2ZXMgdGhlIGN1cnJlbnQgc3RhdGUgYW5kIHJldHVybnMgYSBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZC5cbiAqL1xudHlwZSBOb2RlRnVuY3Rpb248VFN0YXRlPiA9IChzdGF0ZTogVFN0YXRlKSA9PiBQcm9taXNlPFBhcnRpYWw8VFN0YXRlPj4gfCBQYXJ0aWFsPFRTdGF0ZT47XG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGEgc3RyaW5nIGtleSB0byBkZXRlcm1pbmUgdGhlIG5leHQgbm9kZSBpbiBhIGNvbmRpdGlvbmFsIGVkZ2UuXG4gKi9cbnR5cGUgQ29uZGl0aW9uYWxFZGdlUmVzb2x2ZXI8VFN0YXRlPiA9IChzdGF0ZTogVFN0YXRlKSA9PiBzdHJpbmc7XG5cbmludGVyZmFjZSBFZGdlIHtcbiAgc291cmNlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBEaXJlY3RFZGdlIGV4dGVuZHMgRWRnZSB7XG4gIHRhcmdldDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQ29uZGl0aW9uYWxFZGdlPFRTdGF0ZT4gZXh0ZW5kcyBFZGdlIHtcbiAgcmVzb2x2ZXI6IENvbmRpdGlvbmFsRWRnZVJlc29sdmVyPFRTdGF0ZT47XG4gIHRhcmdldHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG59XG5cbi8qKlxuICogQSBjbGFzcyBmb3IgYnVpbGRpbmcgYW5kIHJ1bm5pbmcgc3RhdGVmdWwgZ3JhcGhzLlxuICogVGhlIGdyYXBoIGlzIGRlZmluZWQgYnkgYSBzZXQgb2Ygbm9kZXMgYW5kIGVkZ2VzLCBhbmQgaXQgcHJvY2Vzc2VzIGRhdGFcbiAqIGJ5IG1vdmluZyB0aHJvdWdoIHRoZSBub2RlcywgdXBkYXRpbmcgYSBzdGF0ZSBvYmplY3QgYXQgZWFjaCBzdGVwLlxuICovXG5leHBvcnQgY2xhc3MgU3RhdGVHcmFwaDxUU3RhdGUgZXh0ZW5kcyBvYmplY3Q+IHtcbiAgcHJpdmF0ZSByZWFkb25seSBub2RlcyA9IG5ldyBNYXA8c3RyaW5nLCBOb2RlRnVuY3Rpb248VFN0YXRlPj4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBlZGdlcyA9IG5ldyBNYXA8c3RyaW5nLCBEaXJlY3RFZGdlIHwgQ29uZGl0aW9uYWxFZGdlPFRTdGF0ZT4+KCk7XG4gIHByaXZhdGUgc3RhcnROb2RlID0gJyc7XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBub2RlIHRvIHRoZSBncmFwaC5cbiAgICogQHBhcmFtIG5hbWUgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoZSBub2RlLlxuICAgKiBAcGFyYW0gbm9kZSAtIFRoZSBmdW5jdGlvbiB0byBleGVjdXRlIGZvciB0aGlzIG5vZGUuXG4gICAqIEByZXR1cm5zIFRoZSBgU3RhdGVHcmFwaGAgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYWRkTm9kZShuYW1lOiBzdHJpbmcsIG5vZGU6IE5vZGVGdW5jdGlvbjxUU3RhdGU+KTogdGhpcyB7XG4gICAgaWYgKHRoaXMubm9kZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgXCIke25hbWV9XCIgaXMgYWxyZWFkeSBkZWZpbmVkLmApO1xuICAgIH1cbiAgICB0aGlzLm5vZGVzLnNldChuYW1lLCBub2RlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgZGlyZWN0IGVkZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gICAqIEBwYXJhbSBzb3VyY2UgLSBUaGUgbmFtZSBvZiB0aGUgc291cmNlIG5vZGUuIFVzZSBgU1RBUlRgIHRvIGRlZmluZSB0aGUgZW50cnkgcG9pbnQuXG4gICAqIEBwYXJhbSB0YXJnZXQgLSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEByZXR1cm5zIFRoZSBgU3RhdGVHcmFwaGAgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYWRkRWRnZShzb3VyY2U6IHN0cmluZywgdGFyZ2V0OiBzdHJpbmcpOiB0aGlzIHtcbiAgICBpZiAoc291cmNlID09PSBTVEFSVCkge1xuICAgICAgaWYgKHRoaXMuc3RhcnROb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhcnQgbm9kZSBpcyBhbHJlYWR5IGRlZmluZWQuJyk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0Tm9kZSA9IHRhcmdldDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmVkZ2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFuIGVkZ2UgZnJvbSBcIiR7c291cmNlfVwiIGlzIGFscmVhZHkgZGVmaW5lZC5gKTtcbiAgICB9XG4gICAgdGhpcy5lZGdlcy5zZXQoc291cmNlLCB7IHNvdXJjZSwgdGFyZ2V0IH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjb25kaXRpb25hbCBlZGdlIGZyb20gYSBzb3VyY2Ugbm9kZSB0byBtdWx0aXBsZSBwb3NzaWJsZSB0YXJnZXQgbm9kZXMuXG4gICAqIFRoZSBwYXRoIHRha2VuIGlzIGRldGVybWluZWQgYnkgdGhlIG91dHB1dCBvZiBhIHJlc29sdmVyIGZ1bmN0aW9uLlxuICAgKiBAcGFyYW0gc291cmNlIC0gVGhlIG5hbWUgb2YgdGhlIHNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gcmVzb2x2ZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleSB0byBzZWxlY3QgdGhlIHRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gdGFyZ2V0cyAtIEEgbWFwIHdoZXJlIGtleXMgYXJlIHJlc29sdmVyIG91dHB1dHMgYW5kIHZhbHVlcyBhcmUgdGFyZ2V0IG5vZGUgbmFtZXMuXG4gICAqIEByZXR1cm5zIFRoZSBgU3RhdGVHcmFwaGAgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgYWRkQ29uZGl0aW9uYWxFZGdlcyhcbiAgICBzb3VyY2U6IHN0cmluZyxcbiAgICByZXNvbHZlcjogQ29uZGl0aW9uYWxFZGdlUmVzb2x2ZXI8VFN0YXRlPixcbiAgICB0YXJnZXRzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICApOiB0aGlzIHtcbiAgICBpZiAodGhpcy5lZGdlcy5oYXMoc291cmNlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbiBlZGdlIGZyb20gXCIke3NvdXJjZX1cIiBpcyBhbHJlYWR5IGRlZmluZWQuYCk7XG4gICAgfVxuICAgIHRoaXMuZWRnZXMuc2V0KHNvdXJjZSwgeyBzb3VyY2UsIHJlc29sdmVyLCB0YXJnZXRzIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGVzIHRoZSBncmFwaCBpbnRvIGFuIGV4ZWN1dGFibGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbiBgaW52b2tlYCBtZXRob2QgdG8gcnVuIHRoZSBncmFwaC5cbiAgICovXG4gIGNvbXBpbGUoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0Tm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHcmFwaCBtdXN0IGhhdmUgYSBzdGFydGluZyBwb2ludCBkZWZpbmVkIHdpdGggYGFkZEVkZ2UoU1RBUlQsIC4uLilgLicpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGVzIHRoZSBncmFwaCB3aXRoIGEgZ2l2ZW4gaW5pdGlhbCBzdGF0ZS5cbiAgICAgICAqIEBwYXJhbSBpbml0aWFsU3RhdGUgLSBUaGUgaW5pdGlhbCBzdGF0ZSB0byBiZWdpbiBleGVjdXRpb24gd2l0aC5cbiAgICAgICAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uLCBpbmNsdWRpbmcgYW4gQWJvcnRTaWduYWwuXG4gICAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBmaW5hbCBzdGF0ZSBvZiB0aGUgZ3JhcGguXG4gICAgICAgKi9cbiAgICAgIGludm9rZTogYXN5bmMgKFxuICAgICAgICBpbml0aWFsU3RhdGU6IFRTdGF0ZSxcbiAgICAgICAgY29uZmlnOiB7IHNpZ25hbD86IEFib3J0U2lnbmFsOyBydW5JZD86IHN0cmluZyB9ID0ge30sXG4gICAgICApOiBQcm9taXNlPFRTdGF0ZT4gPT4ge1xuICAgICAgICBsZXQgY3VycmVudE5vZGVOYW1lID0gdGhpcy5zdGFydE5vZGU7XG4gICAgICAgIGxldCBjdXJyZW50U3RhdGUgPSB7IC4uLmluaXRpYWxTdGF0ZSB9O1xuICAgICAgICBjb25zdCB7IHNpZ25hbCwgcnVuSWQ6IGdyYXBoUnVuSWQgfSA9IGNvbmZpZztcblxuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGVOYW1lICE9PSBFTkQpIHtcbiAgICAgICAgICBpZiAoc2lnbmFsPy5hYm9ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignR3JhcGggZXhlY3V0aW9uIGFib3J0ZWQnKTtcbiAgICAgICAgICAgIGVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRoaXMubm9kZXMuZ2V0KGN1cnJlbnROb2RlTmFtZSk7XG4gICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIFwiJHtjdXJyZW50Tm9kZU5hbWV9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgY29uc3Qgbm9kZVJ1bklkID0gY3JlYXRlSWQoKTtcblxuICAgICAgICAgIGNvbnN0IHRyYWNlQ2FuZGlkYXRlID0gKGN1cnJlbnRTdGF0ZSBhcyB7IHRyYWNlQnVmZmVyPzogVHJhY2VCdWZmZXIgfSkudHJhY2VCdWZmZXI7XG4gICAgICAgICAgY29uc3QgdHJhY2VCdWZmZXI6IFRyYWNlQnVmZmVyIHwgbnVsbCA9XG4gICAgICAgICAgICBncmFwaFJ1bklkICYmIHRyYWNlQ2FuZGlkYXRlID8gdHJhY2VDYW5kaWRhdGUgOiBudWxsO1xuICAgICAgICAgIGxldCBub2RlUnVuRW50cnk6IEJ1ZmZlcmVkTm9kZVJ1biB8IG51bGwgPSBudWxsO1xuICAgICAgICAgIGlmICh0cmFjZUJ1ZmZlcikge1xuICAgICAgICAgICAgbm9kZVJ1bkVudHJ5ID0ge1xuICAgICAgICAgICAgICBpZDogbm9kZVJ1bklkLFxuICAgICAgICAgICAgICBub2RlTmFtZTogY3VycmVudE5vZGVOYW1lLFxuICAgICAgICAgICAgICBzdGFydFRpbWUsXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogc3RhcnRUaW1lLFxuICAgICAgICAgICAgICB1cGRhdGVkQXQ6IHN0YXJ0VGltZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0cmFjZUJ1ZmZlci5ub2RlUnVucy5wdXNoKG5vZGVSdW5FbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHN0YXRlVXBkYXRlOiBQYXJ0aWFsPFRTdGF0ZT4gfCB1bmRlZmluZWQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXRlVXBkYXRlID0gYXdhaXQgY3VycmVudE5vZGUoY3VycmVudFN0YXRlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBSZXRocm93IHRoZSBlcnJvciB0byBiZSBoYW5kbGVkIGJ5IHRoZSBnbG9iYWwgZ3JhcGggcnVuIGhhbmRsZXIuXG4gICAgICAgICAgICAvLyBUaGUgbm9kZSBleGVjdXRpb24gd2lsbCBiZSBsZWZ0IGluIGEgcGVuZGluZyBzdGF0ZSAobm8gZW5kVGltZSksIHdoaWNoIGlzIGV4cGVjdGVkLlxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZVJ1bkVudHJ5KSB7XG4gICAgICAgICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIG5vZGVSdW5FbnRyeS5lbmRUaW1lID0gZW5kVGltZTtcbiAgICAgICAgICAgIG5vZGVSdW5FbnRyeS5kdXJhdGlvbk1zID0gZW5kVGltZS5nZXRUaW1lKCkgLSBzdGFydFRpbWUuZ2V0VGltZSgpO1xuICAgICAgICAgICAgbm9kZVJ1bkVudHJ5LnVwZGF0ZWRBdCA9IGVuZFRpbWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZVVwZGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdXJyZW50U3RhdGUgPSB7IC4uLmN1cnJlbnRTdGF0ZSwgLi4uc3RhdGVVcGRhdGUgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBlZGdlID0gdGhpcy5lZGdlcy5nZXQoY3VycmVudE5vZGVOYW1lKTtcbiAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYE5vIGVkZ2UgZm91bmQgZnJvbSBub2RlIFwiJHtjdXJyZW50Tm9kZU5hbWV9XCIuIEFsbCBub2RlcyBtdXN0IGhhdmUgYW4gb3V0Z29pbmcgZWRnZS5gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJ3RhcmdldCcgaW4gZWRnZSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGVOYW1lID0gZWRnZS50YXJnZXQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IGVkZ2UucmVzb2x2ZXIoY3VycmVudFN0YXRlKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb2RlID0gZWRnZS50YXJnZXRzW3RhcmdldEtleV07XG4gICAgICAgICAgICBpZiAoIW5leHROb2RlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgQ29uZGl0aW9uYWwgZWRnZSBmcm9tIFwiJHtjdXJyZW50Tm9kZU5hbWV9XCIgcmVzb2x2ZWQgdG8gXCIke3RhcmdldEtleX1cIiwgd2hpY2ggaXMgbm90IGEgdmFsaWQgdGFyZ2V0LmAsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Tm9kZU5hbWUgPSBuZXh0Tm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxufVxuIl19